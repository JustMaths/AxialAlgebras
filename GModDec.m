/*

Package for G-modules in magma to make use of the decomposition

Authors: Justin McInroy, Sergey Shpectorov
With thanks to Dmitrii Pasechnik

*/
declare type GModDec[GModDecElt];

declare attributes GModDec:
  group,              // The group G
  irreducibles,       // A SeqEnum of all the irreducibles for the group G
  multiplicities,     // A SeqEnum of the multiplicities of each irreducible
  basis,              // ?? Something to describe how to build an actual Gmod
  overmodule,         // ?? Something descibing the overmodule if it was created as a submodule, if not then the module itself.
  coveringmodule,     // ?? Something descibing the covering module if it was created as a quotient, if not then the module itself.
  tensors,            // ?? A SeqEnum of SeqEnums of the tensor products of the irreducibles
  symmetric_squares;  // ?? A SeqEnum of the symmetric squares of the irreducibles

// NB Not sure quite how to save the info for tensors and symmetric_squares yet.  Need both a seq of multiplicities for each and the maps mapping the tensor to our representation of it.
  
declare attributes GModDecElt:
  parent,           // Parent
  elt;              // A List of matrices, one for each irreducible.
  
/*

=======  Functions for a GModDec  =======

*/
intrinsic Print(M::GModDec)
  {
  Prints a GModDec.
  }
  printf "A DecomposedGModule of dimension %o over %o", Dimension(M), BaseRing(M);
end intrinsic;

intrinsic Group(M::GModDec) -> Grp
  {
  The group G of the G-module M.
  }
  return M`group;
end intrinsic;

intrinsic Dimension(M::GModDec) -> RngIntElt
  {
  Dimension of the module.
  }
  return &+[ M`multiplicities[i]*Dimension(M`irreducibles[i]) : i in [1..#M`multiplicities] | M`multiplicities[i] ne 0];
end intrinsic;

intrinsic BaseField(M::GModDec) -> Fld
  {
  Base field of the module.
  }
  return BaseField(M`irreducibles[1]);
end intrinsic;

intrinsic BaseRing(M::GModDec) -> Rng
  {
  Base ring of the module.
  }
  return BaseRing(M`irreducibles[1]);
end intrinsic;
/*

=======  Creating a GModDecs  =======

*/
intrinsic DecomposedGModule(M::Gmod) -> GModDec
  {
  The GModDec of the magma G-module M.
  }
  // NOT YET IMPLMENTED
  // return MM;
end intrinsic;

intrinsic DecomposedGModule(S::SeqEnum[Mtrx]) -> GModDec
  {
  Returns the decomposed G-module generated by the matrices in S.
  }
  // NOT YET IMPLMENTED
  // return null;
end intrinsic;
/*

=======  Building new GModDecs out of old ones  =======

*/
intrinsic SubConstructor(M::GModDec, X::.) -> GModDec
  {
  The submodule generated by X.
  }
  // NOT YET IMPLMENTED
  // return null;
end intrinsic;

// No idea if this is the right intrinsic name to get quo...
intrinsic QuoConstructor(M::GModDec, X::.) -> GModDec, Map
  {
  The quotient of M by the submodule generated by X and also the quotient map.
  }
  // NOT YET IMPLMENTED
  // return null, null;
end intrinsic;

intrinsic DirectSum(M::GModDec, N::GModDec) -> GModDec, Map, Map, Map, Map
  {
  The direct sum of M and N, the two inclusion maps and the two projection maps.
  }
  // NOT YET IMPLMENTED
  // return null, null, null, null, null;
end intrinsic;

intrinsic DirectSum(Q::SeqEnum[GModDec]) -> GModDec, SeqEnum, SeqEnum
  {
  The direct sum of the modules in Q, a sequence of inclusion maps and a sequence of projection maps.
  }
  // NOT YET IMPLMENTED
  // return null, null, null;
end intrinsic;

intrinsic TensorProduct(M::GModDec, N::GModDec) -> GModDec
  {
  The tensor product of M and N.
  }
  // NOT YET IMPLMENTED
  // return null;
end intrinsic;

intrinsic SymmetricSquare(M::GModDec) -> GModDec
  {
  The symmetric square of M.
  }
  // NOT YET IMPLMENTED
  // return null;
end intrinsic;

intrinsic Restriction(M::GModDec, H::Grp) -> GModDec
  {
  Returns the restriction of the G-module M to an H-module where H is a subgroup of G.
  }
  // NOT YET IMPLMENTED
  // return null;
end intrinsic;

intrinsic ChangeField(M::GModDec, F::Fld) -> GModDec
  {
  Returns the module defined over the field F.
  }
  // NOT YET IMPLMENTED
  // return null;
end intrinsic;

intrinsic ChangeRing(M::GModDec, R::Rng) -> GModDec
  {
  Returns the module defined over the ring R.
  }
  // NOT YET IMPLMENTED
  // return null;
end intrinsic;

intrinsic Moduli(M::GModDec) -> SeqEnum
  {
  The column moduli of the module M over a euclidean domain.
  }
  // NOT YET IMPLMENTED
  // return null;
end intrinsic;
/*

=======  Functions on submodules of GModDecs  =======

*/
intrinsic Parent(M::GModDec) -> GModDec
  {
  The module which contains M as a submodule.
  }
  // NOT YET IMPLMENTED
  // return null;
end intrinsic;

intrinsic 'eq'(M::GModDec, N::GModDec) -> BoolElt
  {
  Equality of two submodules M and N.
  }
  // NOT YET IMPLMENTED
  // return null;
end intrinsic;

intrinsic IsIsomorphic(M::GModDec, N::GModDec) -> BoolElt, Map
  {
  Returns whether M and N are isomorphic and if so also returns the ismomorphism.
  }
  // NOT YET IMPLMENTED
  // return null;
end intrinsic;

intrinsic 'subset'(N::GModDec, M::GModDec) -> BoolElt
  {
  Whether N is a submodule of and M.
  }
  // NOT YET IMPLMENTED
  // return null;
end intrinsic;

intrinsic '+'(M::GModDec, N::GModDec) -> GModDec
  {
  The sum of the two submodules M and N.
  }
  // NOT YET IMPLMENTED
  // return null;
end intrinsic;

intrinsic 'meet'(M::GModDec, N::GModDec) -> GModDec
  {
  The intersection of two submodules M and N.
  }
  // NOT YET IMPLMENTED
  // return null;
end intrinsic;
/*

=======  Translating between different structures  =======

*/
intrinsic GModule(M::GModDec) -> GMod
  {
  The magma G-module given by M.
  }
  // NOT YET IMPLMENTED
  // return null;
end intrinsic;

intrinsic VectorSpace(M::GModDec) -> ModTupRng
  {
  The vector space defined by M.
  }
  return VectorSpace(BaseRing(M), Dimension(M));
end intrinsic;
/*

=======  GModDecElts  =======

*/
intrinsic Parent(x::GModDecElt) -> GModDec
  {
  Parent of x.
  }
  return x`parent;
end intrinsic;

intrinsic Print(x::GModDecElt)
  {
  Print x.
  }
  //printf "%o", x`elt;
end intrinsic;

intrinsic 'eq'(x::GModDecElt, y::GModDecElt) -> BoolElt
  {
  Equality of elements.
  }
  require x`parent eq y`parent: "The two elements are not in the same module.";
  return x`elt eq y`elt;
end intrinsic;

intrinsic 'in'(x::GModDecElt, M::GModDec) -> BoolElt
  {
  Returns whether x is in M.
  }
  // Need to consider cases where x in naturally in an overmodule N of M
  /*
  if x`parent eq M then
    return true;
  end if;
  */
  // return x`parent eq M;
end intrinsic;

intrinsic Hash(x::GModDecElt) -> RngIntElt
  {
  Returns the hash value of x.
  }
  return Hash(<x`elt>);
end intrinsic;

intrinsic Eltseq(x::GModDecElt) -> SeqEnum
  {
  Returns the sequence of coefficients of x`elt.
  }
  // NOT YET IMPLMENTED
  // return null;
end intrinsic;

intrinsic Vector(x::GModDecElt) -> ModTupFld
  {
  Returns the vector.
  }
  // NOT YET IMPLMENTED
  // return null;
end intrinsic;

intrinsic IsZero(x::GModDecElt) -> BoolElt
  {
  Returns whether an element is zero or not.
  }
  return forall{ M : M in x`elt | IsZero(M)};
end intrinsic;

function CreateElement(M, x)
  xx := New(GModDecElt);
  xx`parent := M;
  xx`elt := x;
  return xx;
end function;

intrinsic IsCoercible(M::GModDec, x::.) -> BoolElt, GModDecElt
  {
  Returns whether x is coercible into A and the result if so.
  }
  if Type(x) eq List and #x eq #M`irreducibles and
      forall{ x[i] : i in [1..#x] |
         ISA(Type(x[i]), Mtrx) and
         NumberOfColumns(x[i]) eq Dimension(M`irreducibles[i])}
   then
    return true, CreateElement(M, x);
  // COMPLETE SOME MORE CASES
  else
    return false, _;
  end if;
end intrinsic;

intrinsic Zero(M::GModDec) -> GModDecElt
  {
  Returns the zero element of M.
  }
  return CreateElement(M, [* Matrix(BaseRing(M), 0, Dimension(U), []) : U in M`irreducibles*]);
end intrinsic;

intrinsic Basis(M::GModDec) -> SeqEnum
  {
  Basis of the module.
  }
  // NOT YET IMPLMENTED
  // return null;
end intrinsic;

intrinsic '.'(M::GModDec, i::RngIntElt) -> GModDecElt
  {
  The ith basis element of the module.
  }
  // NOT YET IMPLMENTED
  // return null;
end intrinsic;
/*

=======  Operations on GModDecElts  =======

*/
intrinsic '+'(x::GModDecElt, y::GModDecElt) -> GModDecElt
  {
  Sums x and y.
  }
  require Parent(x) eq Parent(y): "x and y are not in the same module.";
  return CreateElement(Parent(x), [* x`elt[i]+y`elt[i] : i in [1..#x`elt]*]);
end intrinsic;

intrinsic '-'(x::GModDecElt) -> GModDecElt
  {
  Negation of the input.
  }
  return CreateElement(Parent(x), [* -m : m in x`elt*]);
end intrinsic;

intrinsic '-'(x::GModDecElt, y::GModDecElt) -> GModDecElt
  {
  Subtracts x and y.
  }
  require Parent(x) eq Parent(y): "x and y are not in the same module.";
  return CreateElement(Parent(x), [* x`elt[i]-y`elt[i] : i in [1..#x`elt]*]);
end intrinsic;

intrinsic '*'(al::RngElt, x::GModDecElt) -> GModDecElt
  {
  Returns the product of al and x.
  }
  require al in BaseRing(Parent(x)): "The scalar given is not in the base ring of the module.";
  return CreateElement(Parent(x), [* al*m : m in x`elt*]);
end intrinsic;

intrinsic '*'(x::GModDecElt, al::RngElt) -> GModDecElt
  {
  "
  }
  return al*x;
end intrinsic;

intrinsic '/'(x::GModDecElt, al::RngElt) -> GModDecElt
  {
  Returns x divided by al.
  }
  require al in BaseRing(Parent(x)): "The scalar given is not in the base ring of the module.";
  return CreateElement(Parent(x), [* m/al : m in x`elt*]);
end intrinsic;

intrinsic '*'(x::GModDecElt, g::GrpElt) -> GModDecElt
  {
  The image of x under the action of g.
  }
  M := Parent(x);
  require g in Group(M): "g is not a member of the group which acts on the module containing x.";
  // NOT YET IMPLMENTED
  // return null;
end intrinsic;
